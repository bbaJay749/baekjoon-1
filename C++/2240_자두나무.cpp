#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	int T, W;
	cin >> T >> W;
	
	int pos[T+1];
	for(int i = 1; i <= T; i++){
		cin >> pos[i];
	}
	
	int dp[2][W+1][T+1];
	for(int i = 0; i <= W; i++){
		for(int j = 0; j <= T; j++){
			for(int k = 0; k < 2; k++){
				dp[k][i][j] = 0;
			}
		}
	} // 1차원: 자두(사람)의 위치, 2차원(행): 움직일 수 있는 최대 횟수, 3차원(열): 초(시간)
	
	for(int i = 1; i <= T; i++){
		if(pos[i] == 1){
			dp[0][0][i] = dp[0][0][i-1] + 1;
		}
		else{
			dp[0][0][i] = dp[0][0][i-1];
		}
	} // 초기화: 한 번도 움직이지 않은 경우, 초기 위치가 1이기 때문에 자두(과일)가 떨어지는 위치가 1이면 먹을 수 있는 자두의 수 1증가
	
  	// 현재 위치, 현재 시간에서 먹을 수 있는 자두의 수는 위치가 바뀌었을 때 이전 시간에서 먹을 수 있는 자두의 수([k, i, j-1], 위치가 바뀌지 않을 것이기 때문에 이미 위치를 바꾸는 것 가능 -> 같은 i의 값 가져오기) 또는 바뀌지 않았을 때이전 시간에서 먹을 수 있는 자두의 수([k, i-1, j-1], 현재 위치에서 위치 변경 일어나기 때문에 위치를 바꾸는 것 불가능 -> i-1의 값 가져오기) 두 가지로 나누어서 생각해야 함
	for(int i = 1; i <= W; i++){ // 움직일 수 있는 최대 횟수(1 ~ W, 0번일 때는 초기화 하면서 이미 설정 완료)
		for(int j = 1; j <= T; j++){ // 현재 시간(1 ~ T)
			for(int k = 0; k < 2; k++){ // 현재 자두(사람)의 위치(0 ~ 1, 실제 위치는 1 ~ 2이고 인덱스는 -1씩)
				if(pos[j] == k+1){ // 자두(사람)의 위치와 자두(과일)이 떨어지는 위치가 동일하면
					dp[k][i][j] = max(dp[k][i][j-1],dp[(k+1)%2][i-1][j-1]) + 1; // 먹을 수 있는 지두의 수 1 추가
				}
				else{ // 자두(사람)의 위치와 자두(과일)이 떨어지는 위치가 다르면
					dp[k][i][j] = max(dp[k][i][j-1],dp[(k+1)%2][i-1][j-1]); // 먹을 수 있는 지두의 수 추가X
				}
			}
		}
	}
	
	cout << max(dp[0][W][T], dp[1][W][T]);
	
	return 0;
}
