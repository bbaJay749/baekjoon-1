#include <iostream>
using namespace std;

int main() {
	int N, L, R;
	cin >> N >> L >> R;
	
	//1000000007로 나눈 값을 저장하는데 왜 long long int를 썼는지 알 수 없다.... 그냥 int로 선언해서 자꾸 틀렸음ㅠㅠ	
	long long int dp[N+1][N+1][N+1] = {0,}; //index를 1부터하기 위해 N+1크기의 3차원 배열 선언
	dp[1][1][1] = 1; //초기값 설정(N이 1일때는 어디서 보든 하나만 보임)
	
    if(N == 1){ // N이 1일 경우에는 dp[1][1][1]을 제외하고 모두 0이고 뒤에 나올 for문을 거치지 않기 떄문에 예외처리 진행(안하면 출력 안되니까)
        cout << dp[N][L][R]%1000000007; //사실 1000000007 안나눠도 무방
    }
    
     /* n-1개의 건물이 있을 때 건물 하나를 추가한다고 생각해보자
      * 2~n의 건물이 있다고 가정하고 1을 추가! (어차피 1~n-1을 보고 n을 추가하는 것과 같음 1~n-1을 모두 1씩 크게하면 어차피 2~n의 경우의 수와 같아지니까, 1을 추가했을 때 영향력 생각하는게 제일 쉽기 때문에...)
      * 1) 1을 맨 앞에 추가: 왼쪽에서 볼 때 1증가 -> 넣을 수 있는 위치 맨 앞 1개
      * 2) 1을 맨 뒤에 추가: 오른쪽에서 볼 때 1증가 -> 넣을 수 있는 위치 맨 뒤 1개
      * 3) 1을 앞 뒤가 아닌 중간에 추가: 변화 없음(가려지니까) -> 넣을 수 있는 위치 n개 중 맨 앞, 뒤 각각 1개 씩을 뺀 n-2개 */
	for(int n = 2; n <= N; n++){
		for(int l = 1; l <= n; l++){
			for(int r = 1; r <= n; r++){
			     // 3)번경우, 1)번경우, 2)번 경우
				dp[n][l][r] = (dp[n-1][l][r]*(n-2)+dp[n-1][l-1][r]+dp[n-1][l][r-1])%1000000007;
				
				if(n == N && l == L && r == R){
					cout << dp[n][l][r]%1000000007; // 원하는 n,l,r 값 만났을 때 더이상 계산하지 말고 출력하고 끝내
					return 0;
				}
			}
		}
	}
	
	return 0;
}