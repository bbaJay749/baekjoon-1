import sys

if __name__ == '__main__':
	T, W = list(map(int,sys.stdin.readline().split()))
	pos = [int(sys.stdin.readline()) for _ in range(T)]
	
	dp = [[[0]*(T+1) for _ in range(W+1)] for _ in range(2)] # 3차원 배열 필요, 1차원: 자두의 위치(1 or 2), 2차원(행): 최대 이동 횟수, 3차원(열): 초
	
	for i in range(1,T+1): # 초기화, 자두가 한 번도 움직이지 않았을 때
		if pos[i-1] == 1: # 초기 위치가 1이므로 떨어지는 위치가 1인 자두일 때만 먹을 수 있는 자두의 개수 증가
			dp[0][0][i] = dp[0][0][i-1]+1
		else:
			dp[0][0][i] = dp[0][0][i-1]
			
  # 현재 위치, 현재 시간에서 먹을 수 있는 자두의 수는 위치가 바뀌었을 때 이전 시간에서 먹을 수 있는 자두의 수([k, i, j-1], 위치가 바뀌지 않을 것이기 때문에 이미 위치를 바꾸는 것 가능 -> 같은 i의 값 가져오기) 또는 바뀌지 않았을 때이전 시간에서 먹을 수 있는 자두의 수([k, i-1, j-1], 현재 위치에서 위치 변경 일어나기 때문에 위치를 바꾸는 것 불가능 -> i-1의 값 가져오기) 두 가지로 나누어서 생각해야 함     
	for i in range(1,W+1): # 1번 이동 ~ W번 이동
		for j in range(1,T+1): # 1초 ~ T초
			for k in range(2): # 위치 1 ~ 2(인덱스는 -1씩 해주어야 함)
				if k+1 == pos[j-1]: # 자두(과일)가 떨어지는 위치와 자두(사람)의 위치가 같다면
					dp[k][i][j] = max(dp[k][i][j-1],dp[(k+1)%2][i-1][j-1])+1 # 자두의 개수 1개 추가
				else: # 자두(과일)가 떨어지는 위치와 자두(사람)의 위치가 다르다면
					dp[k][i][j] = max(dp[k][i][j-1],dp[(k+1)%2][i-1][j-1]) # 자두의 개수 추가X
					
	print(max(dp[0][W][T],dp[1][W][T]))
